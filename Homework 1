Problem 1.


Your task is to pack products into boxes. A given maximum number of products fits in each box. How many boxes is needed at least?
For example, if there are 10 products and 3 products fit in a box, you need 4 boxes. For instance, you could pack 3, 3, 2 and 2 products into the boxes.
In a file boxes.py, implement the function min_count that returns the smallest number of boxes needed. The parameters of the function are:

product_count: the total number of products
box_size: the number of products that fits in one box

Your function will be tested using a large number of test cases. In each test case, both parameters are integers in the range 1–100

def min_count(product_count, box_size):
    if product_count < 0 :
        return "N/A"
    else:
        box_modulo = product_count % box_size
    if box_modulo == 0:
        return product_count / box_size
    elif box_modulo > 0:
        interim = (product_count - box_modulo)/ box_size
        boxes = interim + int((box_modulo/box_size)+1)
        print(boxes)
if __name__ == "__main__":
    print(min_count(10, 3)) # 4
    print(min_count(10, 4)) # 3
    print(min_count(100, 1)) # 100
    print(min_count(100, 100)) # 1
    print(min_count(100, 99)) # 2
    print(min_count(5, 5)) # 1
    print(min_count(5, 6)) # 1

Problem 2:

Last year was special because (20+25)^2=2025, i.e., the the year is the square of the sum of its first and second halves.
In a file special.py, implement the function check_year that reports if the given year is special. The function should return True or False.
Your function will be tested using many different test cases. In each test case, the year is in the range 1000–9999.


def check_year(year):
    first_part  = year // 100
    second_part= year % 100
    if (first_part + second_part)** 2 == year :
        print ('True')
    else:
         print('False')
        

check_year(2026)

if __name__ == "__main__":
    print(check_year(1995)) # False
    print(check_year(2024)) # False
    print(check_year(2025)) # True
    print(check_year(2026)) # False
    print(check_year(3025)) # True
    print(check_year(5555)) # False

Problem 3:

A University of Helsinki student number is a sequence of nine digits. The first digit is 0 and the last digit is a check value that allows checking for typos in the student number.
The check value is obtained by summing up the other digits multiplied by the values 3,7,1,3,7,1,3,7 in the left-to-right order. If the sum is a multiple of 10, the check digit is 0. Otherwise, the check digit is the distance of the sum to the next multiple of 10.
For example, if the student number is 012749139, the sum is 3 \cdot 0 + 7 \cdot 1 + 1 \cdot 2 + 3 \cdot 7 + 7 \cdot 4 + 1 \cdot 9 + 3 \cdot 1 + 7 \cdot 3 = 91. The next multiple of 10 is 100 and the distance to that is 9. Thus the last digit of the student number is 9.
In a file student.py, implement the function check_number that reports if the parameter is a valid student number. The function should return True or False.
Your function will be tested using many different sequences of digits.

def check_number(number):
  lr = []
  z = 0
  check = [3,7,1,3,7,1,3,7]
  c = list(number)
  if c[0] != '0':
    return False
  elif len(c) != 9:
     return False   
 
 
  for x in range(8):
    z = int(c[x]) * check[x]
    lr.append(z)
  last_dig = int(c[8])
 
 
  if sum(lr) % 10 == 0 and  last_dig == 0:
   return True
  elif (sum(lr) + last_dig)% 10 == 0:
   return True
  else :
   return False
if __name__ == "__main__":
    print(check_number("012749138")) # False
    print(check_number("012749139")) # True
    print(check_number("013333337")) # True
    print(check_number("012345678")) # False
    print(check_number("012344550")) # True
    print(check_number("1337")) # False
    print(check_number("0127491390")) # False




Problem 4:

Your task is to divide a string into segments so that each segment is a repeat of the same character. The segments should be represented as a list of pairs containing the segments lengths and characters.

For example, the string aaabbccdddd has four segments and can be represented as the list [(3, 'a'), (2, 'b'), (2, 'c'), (4, 'd')].

In a file segments.py, implement the function find_segments with a string as a parameter. The function returns a list of pairs representing the segments of the string.

Your function will be tested using many different strings. Each test string consists of the characters a–z and contains 1–100 characters.

def find_segments(data):
    counted = {}
    answer = []
    for i in data:
        if i not in counted:
            counted[i] = 1
        else:
            counted[i] +=1
    answer = list(counted.items())
    return answer


if __name__ == "__main__":
    print(find_segments("aaabbccdddd"))
    # [(3, 'a'), (2, 'b'), (2, 'c'), (4, 'd')]

    print(find_segments("aaaaaaaaaaaaaaaaaaaa"))
    # [(20, 'a')]

    print(find_segments("abcabc"))
    # [(1, 'a'), (1, 'b'), (1, 'c'), (1, 'a'), (1, 'b'), (1, 'c')]

    print(find_segments("kissa"))
    # [(1, 'k'), (1, 'i'), (2, 's'), (1, 'a')]


  # Problem 5
The course material includes two different ways to implement the function count_even:
# implementation 1

def count_even(numbers):
    result = 0
    for x in numbers:
        if x % 2 == 0:
            result += 1
    return result

# implementation 2
def count_even(numbers):
    return sum(x % 2 == 0 for x in numbers)

Compare the efficiencies of the two implementations using a list that contains 10^7 randomly chosen numbers.
In this exercise, you get a point automatically when you submit the test results and the code that you used.

import random 
import time

def count_even(numbers):
     result = 0
     for x in numbers:
        if x % 2 == 0:
            result += 1
     return result

n = 10**7
print("n:", n)
random.seed(10**8)
numbers = [random.randint(1, 10 **6) for _ in range(n)]


start_time = time.time()
res = count_even(numbers)
end_time = time.time()

print("res", res)
print("time:", round(end_time - start_time, 2),"s")


import random 
import time

n = 10**7
print("n:", n)
random.seed(10*4)
numbers = [random.randint(1, 10 **6) for _ in range(n)]



def count_even(numbers):
    return sum(x % 2 == 0 for x in numbers)




start_time = time.time()
res = count_even(numbers)
end_time = time.time()

print("res", res)
print("time:", round(end_time - start_time, 2),"s")
